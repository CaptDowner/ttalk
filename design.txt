A. Spend some time on rspec testing and test
setups.

B. Decide on how to implement locale.

C. Setup come categories and how to use the 
   foreign keys to populate/access phrases by 
   tag category(ies).

D. setup a skeleton of a page that loads phrases 
   dynamically, based on category.

E: If not in db, where to put global accessible arrays, hashes for things like
   categories list, languages list, voices list in YAML files?

Potential categories might include:

are_you
can_will_you
chat
directions
do_did_you
excuses
foods
greetings
he_she
how
i_im_ive
is
it
kudos_boos
my_may
please
q_and_a
ratings
sports
tech
thats
this_there
top_50
travel
weather
what
you

Alpha distribution of phrases
by first letter of phrase

a -  43
b -   6
c -  40
d -  66
e -   7
f -   8
g -   9
h - 108
i - 228
j -   5
k -   0
l -   7
m -  26
n -  16
o -  15
p -  20
q -   0
r -   3
s -  23
t -  84
u -   0
v -   1
w - 194
x -   0
y -  16
z -   0


order of presentation will be English alpha ASC sorted
column layout will adapt to screen sizes, from small phone 
to large format displays.

1. DONE: Got audio working using Rails. I need a better solution, as I ended 
up using a symbolic link from the ../public/ dir to point to the ../assets/sounds dir.

Should I setup a route specifically for the audio files?

2. Completed 26 i18n translation files. I would like to 
decide on how to store the user's locale information.

The information on the current locale can be passed through:

    URL query parameter  ( http://example.com/?locale=sr )
    URL path  ( http://example.com/sr/ )
    domain name  ( http://example.sr )
    subdomain name  ( http://sr.example.com )
    client supplied information

The subdomain name might be the cleanest, as I can use it now to 
indicate which i18n file to present the translated phrases in while still 
using the current set of audio files and speaking English only all locales.

The site would default to English, so both urls:

http://tommytalker.com and
http://en.tommytalker.com 

should present the default pages in English.

The translations would present as:

http://ja.tommytalker.com for Japanese
http://de.tommytalker.com for German
...
http://zh.tommytalker.com for Chinese (simplified)

I still need to store the locale somewhere.
Obvious choices are:

a. Store it as a user param in the user model.
  user.locale='fr'
  or
  options.locale

b. Detect locale from the user's browser.
# A trivial implementation of using an Accept-Language header would be:

  def set_locale
    I18n.locale = extract_locale_from_accept_language_header
  end

  private
  def extract_locale_from_accept_language_header
    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first
  end

c. Store locale in a session var. But we still need to save it somewhere between sessions.

d. I think that whichever method we use to detect/set it, we should 
still store it as a user param, or an option param, as some browsers 
may say 'en' when the user would prefer 'es'(Spanish).


Long term goals:

different voices(e.g. male, female, child, cartoon)

   voices = %w[male,female.child,cartoon]

   eg. - /rails/app/assets/sounds/male
         /rails/app/assets/sounds/female
         /rails/app/assets/sounds/child
         /rails/app/assets/sounds/cartoon

# abstract this to a program var determined at sign-in
# can be changed during the course of the program by the user
audio_dir = /app/assets/sounds/ # same for all audio files

# user selectable, with default stored in user's Option object.
# and would be appended to the audio_dir at runtime
paths = %w[male/, female/, child/, cartoon/] 

# then, only the audio_fname needs to be stored in the database,
# as each voice would use the same filename for mp3 audio files, 
# served out of a special path for voice selection.

class Option
  # user_id
  # voice:string      # user's preferred default voice: male,female,child,cartoon
  # lang_abbrv:string # user's preferred language abbreviation, eg. "en", "sp", "ru",
  # browsers          # browser(s) that the user is connected/has connected from
  # devices           # array or string of devices that the user connects/has connected with
  # os                # user's last used operating system (linux, osx, android, windblows, etc...)
  # timezone          # user's time zone offset from UTC time 
  #                     can be used for composing dynamic phrases related to 
  #                     date/time of day.
  ###
end

devices  enum %w[android,pc,mac,notebook,tablet,cellphone,other]
os       enum %w[android,linux,osx,windows]
browsers enum%w[ie,safari,chrome,mozilla,tor,opera,torch,maxthon,sea_monkey,avant,deepnet_ex]



  #language:string    # user's preferred full language name, eg. English, Spanish, Russian, ...
      or              # we can infer one of these next two from the one, 
                      # so one one needs to be stored

Current questions

1. For i18n translations, will the default locale be stored in the user model?
   If so, pages can be loaded with a before statment to take the local into
   account. 

   http://blog.lingohub.com/2013/08/internationalization-for-ruby-i18n-gem/

     before_action :set_locale

     def set_locale
       I18n.locale = params[:locale] || I18n.default_locale
     end

The information on the current locale can be passed through:

    URL query parameter  ( http://example.com/?locale=sr )
    URL path  ( http://example.com/sr/ )
    domain name  ( http://example.sr )
    subdomain name  ( http://sr.example.com )
    client supplied information

Setting the locale from the domain name or subdomain makes the 
locale of the current page very obvious and search engines also 
like this approach.

It is easy to implement it in Rails by adding a before_action 
to ApplicationController:

before_action :set_locale

def set_locale
  #extracting from the domain name
  I18n.locale = extract_locale_from_tld || I18n.default_locale

  #extracting from subdomain:
  #I18n.locale = extract_locale_from_subdomain || I18n.default_locale
end

def extract_locale_from_tld
  parsed_locale = request.host.split('.').last
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale  : nil
end

def extract_locale_from_subdomain
  parsed_locale = request.subdomains.first
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale : nil
end
-----------------------------------------------------------
Rails adds all .rb and .yml files from the config/locales directory to translations load path, automatically. The I18n library will use English as a default locale (if different locale is not set, :en will be used for looking up translations).

By default, Rails expects that all the resource files are kept in config/locales. On the other hand, we prefer to keep them organized in the subdirectories that correspond to the locale names. You might find some other mode of organization better suited, for example separating the models localization from the views localization.

Let’s change some settings by overriding the defaults in application.rb:

    let’s organize the resource files in the subdirectories corresponding to locales instead of storing everything in config/locales,
    set :de as the default locale and
    :en, :de and :fr as available locales

config.i18n.load_path += Dir[Rails.root.join('config/locales/**/*.{rb,yml}').to_s]
config.i18n.default_locale = :de
config.i18n.available_locales = [:en, :de, :fr]

Rails is localized to numerous locales (meaning, all the static text 
originating from Rails). For a complete list of available locales 
and information on missing translations or pluralization, you can 
check this page.

For multilingual applications it is necessary to allow the user to 
change the current locale and to keep track of this choice. The 
chosen locale can be stored in a session or a cookie, but this 
practice is not recommended. The reason is, that locales should 
be RESTful – transparent and a part of the URL. For example, when 
a user saves or shares a link to a page that he viewed in a non 
default locale, visiting that link should show the page in that 
same locale and not fall back to the default.

The information on the current locale can be passed through:

    URL query parameter  ( http://example.com/?locale=sr )
    URL path  ( http://example.com/sr/ )
    domain name  ( http://example.sr )
    subdomain name  ( http://sr.example.com )
    client supplied information
-----------------------------------------------------------------------
Passing the locale as a query parameter within the URL

If the locale information is passed in the URL as a query parameter, 
setting the locale can be done in before_action (before_filter prior 
to Rails 4) in the ApplicationController:

before_action :set_locale

def set_locale
  I18n.locale = params[:locale] || I18n.default_locale
end

This requires passing the locale as a URL query parameter and adding it 
to all the links within the application.

Doing this manually (example: link_to( books_url :locale => I18n.locale ) ) 
is not very convenient. Fortunately, Rails comes with a helper method that 
can be overridden: ApplicationController#default_url_options:

# app/controllers/application_controller.rb
def default_url_options(options={})
  { :locale => I18n.locale }
end

As a result, every helper method dependent to url_for (e.g. helpers for named 
routes like root_path or root_url, resource routes like books_path or 
books_url, etc.) will now automatically include the locale in the query string, 
like this: http://localhost:3000/?locale=sr.
--------------------------------------------
A trivial implementation of using an Accept-Language header would be:

def set_locale
  I18n.locale = extract_locale_from_accept_language_header
  end

  private
  def extract_locale_from_accept_language_header
    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first
  end
--------------------------------------------------------------------

I don't have any current plans to support mp3 files 
for additional languages other than English.
The translations are text-only translations in order 
that other language users who may not have complete 
or any knowledge of English can read the phrase in their 
native language, and select the link to have that phrase 
spoken in English.

3. How to best transition from static pages (current)
   to dynamic pages created based on categories?
   * ruby script to read in yml

4. How to setup testing (rspec, minitest, etc...) 
   for initial objects and methods on existing classes.

6. How to best implement the #categories member of the
   Phrase object? Use has_and_belongs_to_many to qualify
   categories as an array of strings? Or as an array or ENUMs 
   that are assigned (locally or globally)? 

   A: via the tag:references member of the Phrase class
   example implementation needed.

   A: DONE: moved string translations from static yml files into Postgres db.

The reason for this approach is that I'd like the initial design to include 
a way for later support of multiple languages. Initially, only the link text 
for the phrases would be translated, so that a Spanish user would read the link 
in Spanish, but when clicked on, the English mp3 file would be output.

# ------------------------------------------------------
# class User
#
# username
# email (or use email for username)
# encrypted password
# language - user's preferred language
# voice      - preference when different voices are available
# ips[]      - array of ips that the user connects/has connected from 
# browsers[] - browser(s) that the user connects/has connected from
# devices[]  - array of devices that the user connects/has connected with
# os         - user's operating system (linux, osx, android, windblows, etc...)
# timezone   - user's time zone offset from UTC time 
#              can be used for composing dynamic phrases related to 
#              date/time of day.
#            
# last_login - datetime
# updated_at - datetime
# created_at - datetime
#
# end
#
# ------------------------------------------------------
# a Phrase can be anything from a single word to 
# a silent spacer. Each will be stored in a 
# similarly named mp3 file along with  the corresponding 
# text. Each phrase (other than silent spacings) will 
# be assigned 1 to x number of categories. 
# ------------------------------------------------------
class Phrase 
  has_many :tags
  belongs_to :language

  #text:string - string of text spoken in mp3 file
  #audio_path:string - mp3 filename
  #tag:references - categories to be included in (I'm not sure how this fits in???)

end

class Language
  #name:string
  #abbrv:string


end

words << text (appended)
mp3stream << mp3files (appended)

# ------------------------------------------------------
# a Statement will represent a buffer of phrases along 
# with the corresponding mp3 data. Once assembled, the
# statement should be able to be played, with the mp3 
# data appending to the output mp3 file/buffer.
#
# A method will be written that concatenates all of the 
# data contained in the sequential mp3 files and produces 
# a single mp3 file with only one set of header data.
# ------------------------------------------------------
class Statement
has many sentences
has many mp3streams

  # an array of Phrase objects
  @text[] = text
  # a buffer of mp3 audio data/files
  @audio = mp3 buffer or file containing 
   all of the audio data for the phrases 
   stored in the rtext buffer
# ------------------------------------------------------
# Initially, there will be 2 modes, Speak mode and 
# Compose mode. Both modes should be selectable from any 
# page and should remain in the current mode until 
# explicity changed.
#
# Speak mode will play the mp3 file data when a link is
# selected.
#
# Compose mode will copy the text and the mp3 filname to 
# the Statement object, and will continue to append mp3
# files and associated text until the Play command is 
# issued.
# ----------------------------------------------------------------
# Future development
#
# Record mode  - TBD - simple recorder for recording speech,
#                so user or friend of user can overwrite or
#                recreate sample in a familar voice
# 
# Edit mode    - TBD - Edit recorded mp3 data with simple trimming 
#                and sound saturation level adjustments.
# ----------------------------------------------------------------

mp3 => file format
  

Complete ID3 specification at http://id3.org/

Usually Mp3 file have the next format:

[ID3 head(10 bytes) | ID3 tags | MP3 frames ]

ID3 is not part of MP3 format, but it's kind of container which 
is used to put information like artists, albums, etc...

The audio data itself are stored in MP3 frames.Every frame starts 
with 4 bytes header which provides meta info (codecs, bitrate, etc).

Every frame has fixed size. So if there are not enough samples at 
the end of last frame, coder adds silence to make frame have necessary 
size. I also found there chunks like LAME3.97 (name and version of coder).

So, all we need to do is to get rid of ID3 container. The following 
solution works for me perfect, no warnings anymore and out file 
became smaller:

# Length of header that describes ID3 container
ID3_HEADER_SIZE = 10

# Get size of ID3 container.
# Length is stored in 4 bytes, and the 7th bit of every byte is ignored.
#
# Example:
#         Hex: 00       00       07       76
#         Bin: 00000000 00000000 00000111 01110110
#    Real bin:                        111  1110110
#    Real dec: 1014
#
def get_id3_size(header)
  result = 0
  str = header[6..9]

  # Read 4 size bytes from left to right applying bit mask to exclude 7th bit
  # in every byte.
  4.times do |i|
    result += (str[i].ord & 0x7F) * (2 ** (7 * (3-i)))
  end

  result
end

def strip_mp3!(raw_mp3)
  # 10 bytes that describe ID3 container.
  id3_header = raw_mp3[0...ID3_HEADER_SIZE]
  id3_size = get_id3_size(id3_header)

  # Offset from which mp3 frames start
  offset = id3_size + ID3_HEADER_SIZE

  # Get rid of ID3 container
  raw_mp3.slice!(0...offset)
  raw_mp3
end

# Read raw mp3s
hi  = File.binread('hi.mp3')
bye = File.binread('bye.mp3')

# Get rid of ID3 tags
strip_mp3!(hi)
strip_mp3!(bye)

# Concatenate mp3 frames
hi << bye

# Save result to disk
File.binwrite('out.mp3', hi)

Program mode => Speak

Links to mp3files containing whole phrases or complete sentences are played on click.

Paste mode => Paste each word or words to an output buffer of text and
concatenate the mp3 files as each word or phrase is added. When the SPEAK 
button is pressed, all of the words in the Paste buffer are spoken.


